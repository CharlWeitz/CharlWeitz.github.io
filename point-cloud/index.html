<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hand Control Sphere - Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        canvas { display: block; }
        #video-container {
            position: absolute;
            top: 0; left: 0;
            width: 200px; height: 150px;
            z-index: 10;
            opacity: 0.6; 
            transform: scaleX(-1);
            border-bottom-right-radius: 10px;
        }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-family: sans-serif;
            font-size: 24px;
            pointer-events: none;
            text-shadow: 0 0 10px #00ffff;
        }
    </style>
</head>
<body>

    <div id="loading">Initializing Camera...</div>
    <video id="input_video" style="display:none"></video>
    <canvas id="video-container"></canvas>

    <!-- Import Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // --- PART 1: THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.03);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Create the Point Cloud Sphere
        const particleCount = 4000;
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const colorObj = new THREE.Color();

        for (let i = 0; i < particleCount; i++) {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            
            const radius = 2.0; 

            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);

            positions.push(x, y, z);

            // Colors: Cyan and Purple mix
            const colorMix = Math.random();
            if(colorMix > 0.8) colorObj.setHex(0xffffff); 
            else if(colorMix > 0.5) colorObj.setHex(0x00ffff); 
            else colorObj.setHex(0xaa00ff); 

            colors.push(colorObj.r, colorObj.g, colorObj.b);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({ 
            size: 0.05, 
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const sphere = new THREE.Points(geometry, material);
        scene.add(sphere);
        
        camera.position.z = 10;

        // --- PART 2: ANIMATION LOOP ---
        let targetScale = 0; // Default to invisible
        let currentScale = 0;

        function animate() {
            requestAnimationFrame(animate);

            // Fast interpolation for snappy response
            const speed = 0.2; 
            currentScale += (targetScale - currentScale) * speed;

            // Prevent negative scaling issues
            let renderScale = Math.max(0.001, currentScale);
            sphere.scale.set(renderScale, renderScale, renderScale);

            sphere.rotation.y += 0.005;
            sphere.rotation.z += 0.002;

            renderer.render(scene, camera);
        }
        animate();

        // --- PART 3: MEDIAPIPE HANDS SETUP ---
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('video-container');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            // Draw video preview
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.restore();

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // --- HAND DETECTED ---
                const landmarks = results.multiHandLandmarks[0];
                
                // Calculate Pinch Distance (Thumb Tip #4 vs Index Tip #8)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];

                // Simple 2D distance
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // Multiplier to make the sphere size feel right
                // Distance is usually 0.0 to 0.3
                // Output scale is roughly 0.0 to 4.0
                let calculatedScale = distance * 12;

                // Ensure it doesn't get too small if hand is present but closed
                if (calculatedScale < 0.5) calculatedScale = 0.5; 
                
                targetScale = calculatedScale;

            } else {
                // --- NO HAND DETECTED ---
                // Retract to zero
                targetScale = 0;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraUtils.start();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>