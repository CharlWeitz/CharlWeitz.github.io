<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Life Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }

        canvas {
            display: block;
        }

        #ui-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 300px;
            background: rgba(20, 20, 20, 0.85);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            backdrop-filter: blur(5px);
            user-select: none;
        }

        h2 { margin: 0 0 10px 0; font-size: 1.2rem; border-bottom: 1px solid #555; padding-bottom: 5px; }

        .control-group {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        label { font-size: 0.9rem; color: #ccc; }
        span.val { font-family: monospace; color: #00d2ff; }

        input[type="range"] {
            width: 50%;
            cursor: pointer;
        }

        button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: #2a2a2a;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        button:hover { background: #444; }
        button.active { background: #005f7a; border-color: #00d2ff; }

        #fps-counter {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #555;
            font-family: monospace;
        }
    </style>
</head>
<body>

    <div id="fps-counter">FPS: 0</div>
    <canvas id="simCanvas"></canvas>

    <div id="ui-container">
        <h2>Particle Life</h2>
        
        <div class="control-group">
            <label>Particles</label>
            <input type="range" id="param-number" min="500" max="3000" step="100" value="1200">
            <span class="val" id="val-number">1200</span>
        </div>

        <div class="control-group">
            <label>Colors (Types)</label>
            <input type="range" id="param-types" min="2" max="6" step="1" value="4">
            <span class="val" id="val-types">4</span>
        </div>

        <div class="control-group">
            <label>Interaction Radius</label>
            <input type="range" id="param-radius" min="10" max="200" value="80">
            <span class="val" id="val-radius">80</span>
        </div>

        <div class="control-group">
            <label>Force Strength</label>
            <input type="range" id="param-force" min="0.1" max="5" step="0.1" value="1.0">
            <span class="val" id="val-force">1.0</span>
        </div>

        <div class="control-group">
            <label>Friction (0-1)</label>
            <input type="range" id="param-friction" min="0.01" max="0.99" step="0.01" value="0.5">
            <span class="val" id="val-friction">0.5</span>
        </div>

        <button id="btn-reset">Randomize Rules & Reset</button>
        <button id="btn-pause">Pause / Play</button>
    </div>

<script>
    /**
     * PARTICLE LIFE SIMULATION
     * 
     * Core Concept:
     * 1. Particles have a color (type).
     * 2. An interaction matrix defines how Color A affects Color B (Attract/Repel).
     * 3. Forces are applied based on distance.
     */

    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency
    const fpsDiv = document.getElementById('fps-counter');

    // UI Elements
    const inputNumber = document.getElementById('param-number');
    const inputTypes = document.getElementById('param-types');
    const inputRadius = document.getElementById('param-radius');
    const inputForce = document.getElementById('param-force');
    const inputFriction = document.getElementById('param-friction');
    const btnReset = document.getElementById('btn-reset');
    const btnPause = document.getElementById('btn-pause');

    // Display Values
    const valNumber = document.getElementById('val-number');
    const valTypes = document.getElementById('val-types');
    const valRadius = document.getElementById('val-radius');
    const valForce = document.getElementById('val-force');
    const valFriction = document.getElementById('val-friction');

    // Simulation State
    let width, height;
    let atoms = [];
    let rules = []; // N x N matrix of attraction/repulsion
    let isPaused = false;
    
    // Configuration
    const config = {
        atomCount: 1200,
        typeCount: 4,
        rMax: 80,         // Maximum interaction distance
        forceFactor: 1.0, // Multiplier for force
        friction: 0.5,    // 1 = no friction, 0 = freeze instantly
        beta: 0.3,        // Repulsion radius threshold (0 to 1)
        dt: 0.02          // Time step
    };

    // Color Palette for particle types
    const colorPalette = [
        '#FF3333', // Red
        '#33FF33', // Green
        '#3333FF', // Blue
        '#FFFF33', // Yellow
        '#33FFFF', // Cyan
        '#FF33FF'  // Magenta
    ];

    // Initialization
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // The Force Function described in the video:
    // 1. Repulsion if very close (0 to beta)
    // 2. Attraction/Repulsion based on matrix (beta to 1)
    function interact(r, attraction) {
        const beta = config.beta;
        
        // Too close: Repel strongly (Universal Pauli exclusion principle-ish)
        if (r < beta) {
            return (r / beta) - 1; 
        } 
        // In range: Apply attraction/repulsion rule with a curve
        else if (beta < r && r < 1) {
            // This math creates a "peak" force in the middle of the range
            return attraction * (1 - Math.abs(2 * r - 1 - beta) / (1 - beta));
        }
        
        return 0;
    }

    function createAtoms() {
        atoms = [];
        for (let i = 0; i < config.atomCount; i++) {
            atoms.push({
                x: Math.random() * width,
                y: Math.random() * height,
                vx: 0,
                vy: 0,
                color: Math.floor(Math.random() * config.typeCount)
            });
        }
    }

    function createRules() {
        rules = [];
        for (let i = 0; i < config.typeCount; i++) {
            rules[i] = [];
            for (let j = 0; j < config.typeCount; j++) {
                // Random float between -1 (repel) and 1 (attract)
                rules[i][j] = (Math.random() * 2) - 1;
            }
        }
        console.log("Rules Matrix Generated:", rules);
    }

    function init() {
        createRules();
        createAtoms();
    }

    // The Physics Loop
    function update() {
        if (isPaused) return;

        // 1. Calculate Velocities based on Forces
        for (let i = 0; i < atoms.length; i++) {
            let fx = 0;
            let fy = 0;
            const a = atoms[i];

            for (let j = 0; j < atoms.length; j++) {
                if (i === j) continue;
                const b = atoms[j];

                // Calculate distance vector
                let dx = b.x - a.x;
                let dy = b.y - a.y;

                // Periodic Boundary Conditions (Toroidal Wrap)
                // If particle is too far, check if it's closer via the edge
                if (dx > width * 0.5) dx -= width;
                if (dx < -width * 0.5) dx += width;
                if (dy > height * 0.5) dy -= height;
                if (dy < -height * 0.5) dy += height;

                const dist = Math.sqrt(dx*dx + dy*dy);

                // Optimization: Ignore if outside interaction radius
                if (dist > 0 && dist < config.rMax) {
                    // Calculate Force
                    // Normalize distance (0 to 1)
                    const r = dist / config.rMax;
                    
                    // Get rule from matrix based on colors
                    const attraction = rules[a.color][b.color];
                    
                    const f = interact(r, attraction);

                    // Convert polar force back to cartesian components
                    // f is magnitude. Direction is (dx/dist, dy/dist).
                    // We multiply by config.forceFactor here.
                    const force = f * config.forceFactor;
                    fx += (dx / dist) * force;
                    fy += (dy / dist) * force;
                }
            }

            // Apply force to velocity (Euler integration)
            a.vx = (a.vx + fx * config.dt) * Math.pow(config.friction, 0.1); // Adjusted friction curve
            a.vy = (a.vy + fy * config.dt) * Math.pow(config.friction, 0.1);
        }

        // 2. Update Positions
        for (let i = 0; i < atoms.length; i++) {
            const a = atoms[i];
            a.x += a.vx;
            a.y += a.vy;

            // Wrap edges (Toroidal geometry)
            if (a.x < 0) a.x += width;
            if (a.x >= width) a.x -= width;
            if (a.y < 0) a.y += height;
            if (a.y >= height) a.y -= height;
        }
    }

    // The Rendering Loop
    function draw() {
        // Clear screen with slight transparency for trails? No, sticking to clean clear for this version.
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, width, height);

        for (let i = 0; i < atoms.length; i++) {
            const a = atoms[i];
            // Simple rectangle is much faster than arc for thousands of particles
            ctx.fillStyle = colorPalette[a.color];
            ctx.fillRect(a.x, a.y, 2, 2); 
        }
    }

    // Main Loop
    let lastTime = 0;
    function loop(timestamp) {
        // FPS Calc
        const dt = timestamp - lastTime;
        lastTime = timestamp;
        if(timestamp % 10 < 1) fpsDiv.innerText = `FPS: ${Math.round(1000/dt)}`;

        update();
        draw();
        requestAnimationFrame(loop);
    }

    // --- Event Listeners ---

    btnReset.addEventListener('click', () => {
        init();
    });

    btnPause.addEventListener('click', () => {
        isPaused = !isPaused;
        btnPause.classList.toggle('active');
    });

    // Parameter inputs
    inputNumber.addEventListener('input', (e) => {
        config.atomCount = parseInt(e.target.value);
        valNumber.innerText = config.atomCount;
        createAtoms(); // Re-create atoms to match count
    });

    inputTypes.addEventListener('input', (e) => {
        config.typeCount = parseInt(e.target.value);
        valTypes.innerText = config.typeCount;
        createRules(); // New rules for new color count
        createAtoms(); // Re-assign colors
    });

    inputRadius.addEventListener('input', (e) => {
        config.rMax = parseInt(e.target.value);
        valRadius.innerText = config.rMax;
    });

    inputForce.addEventListener('input', (e) => {
        config.forceFactor = parseFloat(e.target.value);
        valForce.innerText = config.forceFactor;
    });

    inputFriction.addEventListener('input', (e) => {
        // Invert UI logic: 1 on slider = high friction (slow), 0 = no friction (fast)
        // But in code: velocity *= friction. So 0.9 is slippery, 0.5 is sticky.
        // Let's just map standard drag:
        const val = parseFloat(e.target.value);
        config.friction = 1 - val; // Input 0.1 -> Friction 0.9 (Slippery) | Input 0.9 -> Friction 0.1 (Sticky)
        valFriction.innerText = val;
    });

    // Start
    // Initial config mapping
    config.friction = 1 - parseFloat(inputFriction.value);
    init();
    requestAnimationFrame(loop);

</script>
</body>
</html>