<!DOCTYPE html>
<html lang="en">
<head>
    <title>WebXR: Rotate & Scale Cube</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; touch-action: none; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            color: white;
            text-shadow: 0 0 4px rgba(0,0,0,0.8);
            pointer-events: none;
            background: rgba(0,0,0,0.2);
            padding: 10px 0;
        }
    </style>
</head>
<body>
    <div id="info">Scan floor, tap to place. <br> Swipe to rotate, Pinch to resize.</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // --- DEVICE CHECK ---
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        
        if (isIOS && isSafari) {
            alert("This WebXR experience requires features not natively enabled in iOS Safari. Please use the Mozilla WebXR Viewer app.");
            window.location.href = "https://apps.apple.com/us/app/webxr-viewer/id1295998056";
        }

        // --- APP VARIABLES ---
        let container, camera, scene, renderer, reticle;
        let hitTestSource = null;
        let hitTestSourceRequested = false;

        let placedCube = null; // Track the single cube
        
        // Interaction State
        let initialDist = 0;
        let initialScale = 1;
        let initialTouchX = 0;
        let initialRotationY = 0;

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
            scene.add(light);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            document.body.appendChild(ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test'] 
            }));

            // Reticle for surface detection
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial()
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // Placement Trigger
            const controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);

            // Gesture Listeners
            window.addEventListener('touchstart', onTouchStart, { passive: false });
            window.addEventListener('touchmove', onTouchMove, { passive: false });
            window.addEventListener('resize', onWindowResize);
        }

        function onSelect() {
            // Only place if reticle is visible and no cube exists yet
            if (reticle.visible && !placedCube) {
                const geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x00ff00, 
                    transparent: true, 
                    opacity: 0.6 
                });

                placedCube = new THREE.Mesh(geometry, material);
                reticle.matrix.decompose(placedCube.position, placedCube.quaternion, placedCube.scale);
                
                // Offset by half height (15cm) so it sits on top of the plane
                placedCube.position.y += 0.15;
                scene.add(placedCube);
                
                reticle.visible = false;
                document.getElementById('info').innerHTML = "Cube placed!<br>Swipe to rotate, Pinch to resize.";
            }
        }

        // --- GESTURE LOGIC ---

        function onTouchStart(e) {
            if (!placedCube) return;

            if (e.touches.length === 1) {
                // For Rotation
                initialTouchX = e.touches[0].pageX;
                initialRotationY = placedCube.rotation.y;
            } else if (e.touches.length === 2) {
                // For Scaling (Pinch)
                initialDist = Math.hypot(
                    e.touches[0].pageX - e.touches[1].pageX,
                    e.touches[0].pageY - e.touches[1].pageY
                );
                initialScale = placedCube.scale.x;
            }
        }

        function onTouchMove(e) {
            if (!placedCube) return;
            e.preventDefault(); // Prevent scrolling while interacting

            if (e.touches.length === 1) {
                // Swipe to rotate (Y-axis)
                const deltaX = e.touches[0].pageX - initialTouchX;
                placedCube.rotation.y = initialRotationY + deltaX * 0.01;
            } 
            else if (e.touches.length === 2) {
                // Pinch to scale
                const currentDist = Math.hypot(
                    e.touches[0].pageX - e.touches[1].pageX,
                    e.touches[0].pageY - e.touches[1].pageY
                );
                const scaleFactor = currentDist / initialDist;
                const newScale = initialScale * scaleFactor;
                
                // Set uniform scale
                placedCube.scale.set(newScale, newScale, newScale);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then((viewerSpace) => {
                        session.requestHitTestSource({ space: viewerSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', () => {
                        hitTestSourceRequested = false;
                        hitTestSource = null;
                    });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource && !placedCube) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length) {
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                } else if (placedCube) {
                    // Hide reticle once cube is placed
                    reticle.visible = false;
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>