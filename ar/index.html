<!DOCTYPE html>
<html lang="en">
<head>
    <title>WebXR Bouncing Spheres Cube</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; touch-action: none; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            color: white;
            text-shadow: 0 0 4px rgba(0,0,0,0.8);
            pointer-events: none;
            background: rgba(0,0,0,0.3);
            padding: 10px 0;
        }
    </style>
</head>
<body>
    <div id="info">Scan floor, tap to place the 30cm Kinetic Cube. <br> Swipe to rotate, Pinch to resize.</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // --- MANDATORY DEVICE CHECK ---
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        
        if (isIOS && isSafari) {
            alert("This WebXR experience requires features not natively enabled in iOS Safari. Please use the Mozilla WebXR Viewer app.");
            window.location.href = "https://apps.apple.com/us/app/webxr-viewer/id1295998056";
        }

        let container, camera, scene, renderer, reticle;
        let hitTestSource = null;
        let hitTestSourceRequested = false;

        // Bouncing Spheres Data
        let placedGroup = null; // The container for cube + spheres
        const spheres = [];
        const sphereData = [];
        const numSpheres = 20;
        const cubeSize = 0.3; // 30cm

        // Interaction State
        let initialDist = 0;
        let initialScale = 1;
        let initialTouchX = 0;
        let initialRotationY = 0;

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
            scene.add(light);

            const dirLight = new THREE.DirectionalLight(0xffffff, 2);
            dirLight.position.set(1, 2, 1);
            scene.add(dirLight);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            document.body.appendChild(ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test'] 
            }));

            // Reticle
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.1, 0.12, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial()
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // Placement Trigger
            const controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);

            // Gestures
            window.addEventListener('touchstart', onTouchStart, { passive: false });
            window.addEventListener('touchmove', onTouchMove, { passive: false });
            window.addEventListener('resize', onWindowResize);
        }

        function createKineticCube() {
            const group = new THREE.Group();

            // 1. The Transparent Cube
            const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            const material = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide // See spheres through the back
            });
            const cubeMesh = new THREE.Mesh(geometry, material);
            group.add(cubeMesh);

            // 2. White Wireframe Edges
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff }));
            group.add(line);

            // 3. The Bouncing Spheres
            for (let i = 0; i < numSpheres; i++) {
                const radius = Math.random() * 0.01 + 0.005; // Smaller radius for 30cm cube
                const sGeom = new THREE.SphereGeometry(radius, 16, 16);
                const color = new THREE.Color().setHSL(Math.random(), 0.8, 0.6);
                const sMat = new THREE.MeshPhongMaterial({ color: color, shininess: 100 });
                
                const sphere = new THREE.Mesh(sGeom, sMat);
                
                // Random position inside cube
                const maxPos = (cubeSize / 2) - radius;
                sphere.position.set(
                    (Math.random() - 0.5) * 2 * maxPos,
                    (Math.random() - 0.5) * 2 * maxPos,
                    (Math.random() - 0.5) * 2 * maxPos
                );

                group.add(sphere);
                spheres.push(sphere);
                sphereData.push({
                    radius: radius,
                    mass: radius ** 3,
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.005, // Slower velocity for AR
                        (Math.random() - 0.5) * 0.005,
                        (Math.random() - 0.5) * 0.005
                    ),
                    position: sphere.position
                });
            }

            return group;
        }

        function onSelect() {
            if (reticle.visible && !placedGroup) {
                placedGroup = createKineticCube();
                reticle.matrix.decompose(placedGroup.position, placedGroup.quaternion, placedGroup.scale);
                
                // Sit on the floor
                placedGroup.position.y += (cubeSize / 2);
                scene.add(placedGroup);
                
                reticle.visible = false;
                document.getElementById('info').innerHTML = "Cube placed!<br>Swipe to rotate, Pinch to resize.";
            }
        }

        function updatePhysics() {
            if (!placedGroup) return;

            const boundary = cubeSize / 2;

            for (let i = 0; i < spheres.length; i++) {
                const data = sphereData[i];
                const sphere = spheres[i];

                data.position.add(data.velocity);

                // Boundary Checks (X, Y, Z)
                ['x', 'y', 'z'].forEach(axis => {
                    if (data.position[axis] + data.radius >= boundary) {
                        data.velocity[axis] = -Math.abs(data.velocity[axis]);
                        data.position[axis] = boundary - data.radius;
                    } else if (data.position[axis] - data.radius <= -boundary) {
                        data.velocity[axis] = Math.abs(data.velocity[axis]);
                        data.position[axis] = -boundary + data.radius;
                    }
                });
            }

            // Sphere-to-Sphere collisions
            for (let i = 0; i < spheres.length; i++) {
                for (let j = i + 1; j < spheres.length; j++) {
                    const s1 = sphereData[i];
                    const s2 = sphereData[j];
                    const dist = s1.position.distanceTo(s2.position);
                    const minDist = s1.radius + s2.radius;

                    if (dist < minDist) {
                        // Collision response logic from your file
                        const normal = new THREE.Vector3().subVectors(s1.position, s2.position).normalize();
                        const relativeVelocity = new THREE.Vector3().subVectors(s1.velocity, s2.velocity);
                        const normalVelocity = relativeVelocity.dot(normal);

                        if (normalVelocity < 0) {
                            const impulse = (2 * normalVelocity) / (s1.mass + s2.mass);
                            s1.velocity.sub(normal.clone().multiplyScalar(impulse * s2.mass));
                            s2.velocity.add(normal.clone().multiplyScalar(impulse * s1.mass));
                        }
                    }
                }
            }
        }

        // --- GESTURE LISTENERS ---
        function onTouchStart(e) {
            if (!placedGroup) return;
            if (e.touches.length === 1) {
                initialTouchX = e.touches[0].pageX;
                initialRotationY = placedGroup.rotation.y;
            } else if (e.touches.length === 2) {
                initialDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                initialScale = placedGroup.scale.x;
            }
        }

        function onTouchMove(e) {
            if (!placedGroup) return;
            e.preventDefault();
            if (e.touches.length === 1) {
                const deltaX = e.touches[0].pageX - initialTouchX;
                placedGroup.rotation.y = initialRotationY + deltaX * 0.01;
            } else if (e.touches.length === 2) {
                const currentDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                const newScale = initialScale * (currentDist / initialDist);
                placedGroup.scale.set(newScale, newScale, newScale);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then((viewerSpace) => {
                        session.requestHitTestSource({ space: viewerSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource && !placedGroup) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length) {
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }
            }
            
            updatePhysics();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>